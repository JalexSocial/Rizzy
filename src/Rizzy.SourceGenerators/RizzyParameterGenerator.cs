#nullable enable

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Xml;

#if !NET5_0_OR_GREATER
namespace System.Runtime.CompilerServices
{
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static class IsExternalInit { }
}
#endif

namespace Rizzy.SourceGenerators
{
    [Generator(LanguageNames.CSharp)]
    public class RizzyParameterGenerator : IIncrementalGenerator
    {
        // ... (Constants and Attribute Source remain the same) ...
        private const string RizzyParameterizeAttributeFullName = "Rizzy.RizzyParameterizeAttribute";
        private const string ParameterAttributeFullName = "Microsoft.AspNetCore.Components.ParameterAttribute";
        private const string EditorRequiredAttributeFullName = "Microsoft.AspNetCore.Components.EditorRequiredAttribute";
        private const string ComponentBaseFullName = "Microsoft.AspNetCore.Components.ComponentBase";

        private const string RizzyParameterizeAttributeSource = @"// <auto-generated/>
#nullable enable
namespace Rizzy // Match your actual attribute's namespace
{
    /// <summary>
    /// Marks a Blazor component (which must be a partial class or a .razor file) for generation of a static <c>Params</c>
    /// helper method. This method creates a dictionary of the component's parameters,
    /// suitable for use with Rizzy's View/PartialView rendering methods.
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class RizzyParameterizeAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""RizzyParameterizeAttribute""/> class.
        /// </summary>
        public RizzyParameterizeAttribute() { }
    }
}
#nullable restore
";


        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
                "RizzyParameterizeAttribute.g.cs",
                SourceText.From(RizzyParameterizeAttributeSource, Encoding.UTF8)));

            IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null)!;

            IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
                context.CompilationProvider.Combine(classDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndClasses,
                (spc, source) => ExecuteGeneration(source.Item1, source.Item2, spc));
        }

        private static bool IsSyntaxTargetForGeneration(SyntaxNode node) =>
            node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0 &&
            cds.ToString().Contains("RizzyParameterize");

        private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            return context.Node as ClassDeclarationSyntax;
        }

        private void ExecuteGeneration(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext spc)
        {
            if (classes.IsDefaultOrEmpty) return;

            INamedTypeSymbol? parameterizeAttributeSymbol = compilation.GetTypeByMetadataName(RizzyParameterizeAttributeFullName);
            if (parameterizeAttributeSymbol == null) return;

            INamedTypeSymbol? parameterAttributeSymbol = compilation.GetTypeByMetadataName(ParameterAttributeFullName);
            if (parameterAttributeSymbol == null) return;

            INamedTypeSymbol? editorRequiredAttributeSymbol = compilation.GetTypeByMetadataName(EditorRequiredAttributeFullName);
            if (editorRequiredAttributeSymbol == null) return;

            INamedTypeSymbol? componentBaseSymbol = compilation.GetTypeByMetadataName(ComponentBaseFullName);

            var processedSymbols = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

            foreach (ClassDeclarationSyntax classDec in classes)
            {
                if (spc.CancellationToken.IsCancellationRequested) return;

                SemanticModel semanticModel = compilation.GetSemanticModel(classDec.SyntaxTree);
                if (semanticModel.GetDeclaredSymbol(classDec, spc.CancellationToken) is not INamedTypeSymbol classSymbol) continue;
                
                if (!processedSymbols.Add(classSymbol)) continue;

                if (!classSymbol.GetAttributes().Any(ad => SymbolEqualityComparer.Default.Equals(ad.AttributeClass, parameterizeAttributeSymbol)))
                {
                    continue;
                }

                if (classSymbol.ContainingType != null)
                {
                    spc.ReportDiagnostic(Diagnostic.Create(
                        Diagnostics.NestedTypesNotFullySupportedRule,
                        classSymbol.Locations.FirstOrDefault(),
                        classSymbol.Name));
                    continue;
                }

                var allParameters = CollectParameters(classSymbol, parameterAttributeSymbol, editorRequiredAttributeSymbol, componentBaseSymbol, compilation);

                if (allParameters.Any())
                {
                    bool userDefinedCsFileIsNotPartial = classSymbol.DeclaringSyntaxReferences
                        .Select(sr => sr.GetSyntax(spc.CancellationToken))
                        .Where(syntax => !(syntax.SyntaxTree.FilePath?.EndsWith(".razor.g.cs", StringComparison.OrdinalIgnoreCase) ?? false) &&
                                         (syntax.SyntaxTree.FilePath?.EndsWith(".cs", StringComparison.OrdinalIgnoreCase) ?? false))
                        .OfType<ClassDeclarationSyntax>()
                        .Any(cds => !cds.Modifiers.Any(SyntaxKind.PartialKeyword));

                    if (userDefinedCsFileIsNotPartial)
                    {
                        spc.ReportDiagnostic(Diagnostic.Create(
                            Diagnostics.ComponentMustBePartialRule,
                            classSymbol.Locations.FirstOrDefault(),
                            classSymbol.Name));
                        continue;
                    }

                    string classSource = GeneratePartialClassWithStaticMethod(classSymbol, allParameters);
                    string fqnForHash = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string assemblyNameForHash = classSymbol.ContainingAssembly?.Name ?? "unknownassembly";
                    string uniqueFileName = $"{SanitizeFileName(classSymbol.Name)}_{SanitizeFileName(classSymbol.ContainingNamespace.ToDisplayString())}_{GetFnv1aHashCode(assemblyNameForHash + ":" + fqnForHash).ToString("X8")}.RizzyParams.g.cs";
                    spc.AddSource(uniqueFileName, SourceText.From(classSource, Encoding.UTF8));
                }
            }
        }

        private List<ParameterData> CollectParameters(
            INamedTypeSymbol classSymbol,
            INamedTypeSymbol parameterAttributeSymbol,
            INamedTypeSymbol editorRequiredAttributeSymbol,
            INamedTypeSymbol? componentBaseSymbol,
            Compilation compilation)
        {
            var parametersList = new List<ParameterData>();
            var seenParameterNames = new HashSet<string>(StringComparer.Ordinal);
            var typeHierarchy = new List<INamedTypeSymbol>();

            INamedTypeSymbol? current = classSymbol;
            while (current != null &&
                   current.SpecialType != SpecialType.System_Object &&
                   (componentBaseSymbol == null || !SymbolEqualityComparer.Default.Equals(current.OriginalDefinition, componentBaseSymbol)))
            {
                typeHierarchy.Add(current);
                current = current.BaseType;
            }
            // Process from most derived to base to ensure correct override/hiding behavior
            // typeHierarchy.Reverse(); // Not needed with current seenParameterNames logic

            foreach (var typeInHierarchy in typeHierarchy) // Iterates most-derived first due to loop structure
            {
                var levelParameters = typeInHierarchy.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Select(p => new
                    {
                        Property = p,
                        Attributes = p.GetAttributes(),
                        Location = p.Locations.FirstOrDefault()?.SourceSpan.Start ?? int.MaxValue
                    })
                    .Where(pData => pData.Attributes.Any(ad =>
                        ad.AttributeClass != null &&
                        SymbolEqualityComparer.Default.Equals(ad.AttributeClass, parameterAttributeSymbol)))
                    .Select(pData => new ParameterData(
                        pData.Property,
                        pData.Attributes.Any(ad => ad.AttributeClass != null && SymbolEqualityComparer.Default.Equals(ad.AttributeClass, editorRequiredAttributeSymbol)),
                        pData.Location
                    ))
                     .Where(pd => pd.PropertySymbol.DeclaredAccessibility == Accessibility.Public ||
                                 ((pd.PropertySymbol.DeclaredAccessibility == Accessibility.Protected ||
                                   pd.PropertySymbol.DeclaredAccessibility == Accessibility.Internal ||
                                   pd.PropertySymbol.DeclaredAccessibility == Accessibility.ProtectedOrInternal) &&
                                   SymbolEqualityComparer.Default.Equals(pd.PropertySymbol.ContainingAssembly, compilation.Assembly)))
                    .OrderBy(pd => pd.SourceOrder)
                    .ToList();

                foreach (var paramData in levelParameters)
                {
                    if (seenParameterNames.Add(paramData.PropertySymbol.Name)) // Add returns true if item was added (i.e., not seen before)
                    {
                        parametersList.Add(paramData);
                    }
                    // If seenParameterNames.Add returns false, it means a more derived class already declared this parameter name.
                }
            }
            // The list is now composed of the most-derived versions of parameters.
            // Now sort this final list: required first, then by original declaration order (approximated by inheritance depth then source order).
            return parametersList
                .OrderBy(pd => pd.IsEditorRequired || pd.PropertySymbol.Type.TypeKind == TypeKind.TypeParameter ? 0 : 1) // Group required & generic first
                .ThenByDescending(pd => GetInheritanceDepth(pd.PropertySymbol.ContainingType, classSymbol))
                .ThenBy(pd => pd.SourceOrder)
                .ToList();
        }
        
        private static int GetInheritanceDepth(ITypeSymbol? memberDeclaringType, INamedTypeSymbol topLevelComponentType)
        {
            if (memberDeclaringType == null) return int.MaxValue;
            int depth = 0;
            INamedTypeSymbol? current = topLevelComponentType; 
            while (current != null)
            {
                if (SymbolEqualityComparer.Default.Equals(current.OriginalDefinition, memberDeclaringType.OriginalDefinition))
                {
                    return depth;
                }
                depth++;
                current = current.BaseType;
                if (current?.SpecialType == SpecialType.System_Object) break;
            }
            return int.MaxValue;
        }

        private static string SanitizeFileName(string name)
        {
            return System.Text.RegularExpressions.Regex.Replace(name, @"[<>,\s\.:`]", "_");
        }

        private static uint GetFnv1aHashCode(string text)
        {
            const uint fnvOffsetBasis = 2166136261;
            const uint fnvPrime = 16777619;
            uint hash = fnvOffsetBasis;
            foreach (char c in text)
            {
                hash ^= c;
                hash *= fnvPrime;
            }
            return hash;
        }

        private string GeneratePartialClassWithStaticMethod(INamedTypeSymbol componentSymbol, List<ParameterData> parameters)
        {
            string namespaceName = componentSymbol.ContainingNamespace.IsGlobalNamespace
                ? string.Empty
                : $"namespace {componentSymbol.ContainingNamespace.ToDisplayString()}";

            string className = componentSymbol.Name;
            string typeParametersDeclaration = componentSymbol.IsGenericType
                ? "<" + string.Join(", ", componentSymbol.TypeParameters.Select(tp => tp.Name)) + ">"
                : "";
            string crefTypeName = componentSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

            var methodBuilder = new StringBuilder();

            // Method XML Documentation
            methodBuilder.AppendLine($@"    /// <summary>");
            methodBuilder.AppendLine($@"    /// Creates a dictionary of parameters for the <see cref=""{XmlEncode(crefTypeName)}""/> component, including inherited parameters.");
            methodBuilder.AppendLine($@"    /// Optional parameters (not marked with <see cref=""{EditorRequiredAttributeFullName}""/> and not generic type parameters) can be omitted by passing <see langword=""null""/> (if the type allows it),");
            methodBuilder.AppendLine($@"    /// or by not providing the argument if it has a default value. Non-provided or null optional parameters are not added to the dictionary.");
            methodBuilder.AppendLine($@"    /// Optional generic type parameters (like TValue) become required arguments in this helper method.");
            methodBuilder.AppendLine($@"    /// Generated by Rizzy.SourceGenerators.");
            methodBuilder.AppendLine($@"    /// </summary>");

            foreach (var paramData in parameters) // Parameters are now pre-sorted: required first
            {
                string paramNameCamelCase = ToCamelCase(paramData.PropertySymbol.Name);
                string? paramSummary = GetXmlDocsSummary(paramData.PropertySymbol) ?? $"The value for the <c>{paramData.PropertySymbol.Name}</c> parameter.";
                methodBuilder.AppendLine($@"    /// <param name=""{paramNameCamelCase}"">{XmlEncode(paramSummary)}</param>");
            }
            methodBuilder.AppendLine($@"    /// <returns>A <see cref=""global::System.Collections.Generic.Dictionary{{string,object}}"" /> containing the component parameters.</returns>");
            
            methodBuilder.Append($"    public static global::System.Collections.Generic.Dictionary<string, object?> Params(");

            var firstParam = true;
            foreach (var paramData in parameters) // Iterate through pre-sorted parameters
            {
                if (!firstParam) methodBuilder.Append(", ");

                IPropertySymbol property = paramData.PropertySymbol;
                string paramTypeString = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                string paramName = ToCamelCase(property.Name);
                
                // Simplified Logic:
                // 1. If EditorRequired OR it's a generic type parameter: It's a required argument in Params.
                // 2. Else (optional concrete type): Make it nullable with a default of null.
                bool isGenericTypeParameter = property.Type.TypeKind == TypeKind.TypeParameter;

                if (paramData.IsEditorRequired || isGenericTypeParameter)
                {
                    // Required parameter in the generated method
                    methodBuilder.Append($"{paramTypeString} {paramName}");
                }
                else // Optional concrete type
                {
                    if (property.Type.IsReferenceType || property.Type.NullableAnnotation == NullableAnnotation.Annotated)
                    {
                        string typeWithQuestion = paramTypeString.EndsWith("?") ? paramTypeString : $"{paramTypeString}?";
                        methodBuilder.Append($"{typeWithQuestion} {paramName} = null");
                    }
                    else if (property.Type.IsValueType) // Must be non-nullable value type here (e.g. int, bool)
                    {
                        methodBuilder.Append($"global::System.Nullable<{paramTypeString}> {paramName} = null");
                    }
                    // else - this case should ideally not be hit if previous ones are exhaustive for concrete types
                }
                firstParam = false;
            }
            methodBuilder.AppendLine(")");
            methodBuilder.AppendLine("    {");
            methodBuilder.AppendLine("        var parameters = new global::System.Collections.Generic.Dictionary<string, object?>(global::System.StringComparer.Ordinal);");

            foreach (var paramData in parameters)
            {
                string dictKey = paramData.PropertySymbol.Name;
                string valueName = ToCamelCase(paramData.PropertySymbol.Name);
                bool isGenericTypeParameter = paramData.PropertySymbol.Type.TypeKind == TypeKind.TypeParameter;

                if (paramData.IsEditorRequired || isGenericTypeParameter)
                {
                    // Always add EditorRequired parameters and generic type parameters (which are now required args in Params)
                    methodBuilder.AppendLine($"        parameters.Add(\"{dictKey}\", {valueName});");
                }
                else // Optional concrete types
                {
                    methodBuilder.AppendLine($"        if ({valueName} != null)");
                    methodBuilder.AppendLine( "        {");
                    methodBuilder.AppendLine($"            parameters.Add(\"{dictKey}\", {valueName});");
                    methodBuilder.AppendLine( "        }");
                }
            }

            methodBuilder.AppendLine("        return parameters;");
            methodBuilder.AppendLine("    }");

            // ... (rest of sourceBuilder for class structure remains the same) ...
            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated/>");
            sourceBuilder.AppendLine("#nullable enable"); 
            sourceBuilder.AppendLine("using global::System;"); 
            sourceBuilder.AppendLine("using global::System.Collections.Generic;"); 
            sourceBuilder.AppendLine("using global::Microsoft.AspNetCore.Components;");
            sourceBuilder.AppendLine();

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sourceBuilder.AppendLine(namespaceName);
                sourceBuilder.AppendLine("{");
            }

            string accessibility = componentSymbol.DeclaredAccessibility switch {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                _ => "public"
            };

            sourceBuilder.AppendLine($@"    /// <summary>");
            sourceBuilder.AppendLine($@"    /// Provides a generated helper method <c>Params()</c> for creating a parameter dictionary for the <see cref=""{XmlEncode(crefTypeName)}""/> component.");
            sourceBuilder.AppendLine($@"    /// This <see langword=""partial""/> class is generated by Rizzy.SourceGenerators.");
            sourceBuilder.AppendLine($@"    /// </summary>");

            sourceBuilder.Append($"    {accessibility} partial class {className}{typeParametersDeclaration}");
            if (componentSymbol.IsGenericType)
            {
                sourceBuilder.Append(GetGenericConstraints(componentSymbol));
            }
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("    {");
            sourceBuilder.Append(methodBuilder.ToString());
            sourceBuilder.AppendLine("    }");

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sourceBuilder.AppendLine("}");
            }
            // No #nullable restore needed here

            return sourceBuilder.ToString();
        }

        private string XmlEncode(string? text)
        {
            if (string.IsNullOrEmpty(text)) return string.Empty;
            return System.Security.SecurityElement.Escape(text) ?? text!;
        }

        private string? GetXmlDocsSummary(ISymbol symbol)
        {
            string? xmlDocs = symbol.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: System.Threading.CancellationToken.None);
            if (string.IsNullOrWhiteSpace(xmlDocs)) return null;
            if (!xmlDocs!.TrimStart().StartsWith("<member", StringComparison.OrdinalIgnoreCase) || !xmlDocs.Contains("<summary")) return null;

            try
            {
                using (var stringReader = new System.IO.StringReader(xmlDocs))
                using (var xmlReader = XmlReader.Create(stringReader, new XmlReaderSettings { ConformanceLevel = ConformanceLevel.Fragment }))
                {
                    while (xmlReader.Read())
                    {
                        if (xmlReader.NodeType == XmlNodeType.Element && xmlReader.Name.Equals("summary", StringComparison.OrdinalIgnoreCase))
                        {
                            string summaryContent = xmlReader.ReadInnerXml();
                            return string.IsNullOrWhiteSpace(summaryContent) ? null : summaryContent.Trim();
                        }
                    }
                }
            }
            catch (XmlException) { return null; }
            catch (Exception) { return null; } 
            return null;
        }

        private string GetGenericConstraints(INamedTypeSymbol classSymbol)
        {
            var constraintsBuilder = new StringBuilder();
            foreach (var tp in classSymbol.TypeParameters)
            {
                var constraints = new List<string>();
                if (tp.HasReferenceTypeConstraint) constraints.Add("class");
                if (tp.HasValueTypeConstraint) constraints.Add("struct");
                if (tp.ConstraintTypes.Any())
                {
                     constraints.AddRange(tp.ConstraintTypes
                       .Where(ct => ct.SpecialType != SpecialType.System_Object)
                       .Select(ct => ct.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
                }
                if (tp.HasConstructorConstraint) constraints.Add("new()");

                if (constraints.Count > 0)
                {
                    constraintsBuilder.Append($" where {tp.Name} : {string.Join(", ", constraints)}");
                }
            }
            return constraintsBuilder.ToString();
        }

        private string ToCamelCase(string name)
        {
            if (string.IsNullOrEmpty(name) || char.IsLower(name[0]))
                return name;
            return char.ToLowerInvariant(name[0]) + name.Substring(1);
        }

        private record ParameterData(IPropertySymbol PropertySymbol, bool IsEditorRequired, int SourceOrder);

        private static class Diagnostics
        {
            public static readonly DiagnosticDescriptor ComponentMustBePartialRule = new (
                id: "RZ0001",
                title: "Component must be partial for RizzyParams generation",
                messageFormat: "Component '{0}' implemented in a .cs file must be declared 'partial' to generate the Rizzy 'Params' helper method. .razor files are implicitly partial.",
                category: "Rizzy.SourceGenerator",
                DiagnosticSeverity.Error,
                isEnabledByDefault: true);

            public static readonly DiagnosticDescriptor NestedTypesNotFullySupportedRule = new (
                id: "RZ0002",
                title: "Nested component types not fully supported for Params generation",
                messageFormat: "Component '{0}' is a nested type. Rizzy 'Params' helper generation for nested types is currently not supported. Consider making it a top-level type.",
                category: "Rizzy.SourceGenerator",
                DiagnosticSeverity.Warning,
                isEnabledByDefault: true);
        }
    }
}