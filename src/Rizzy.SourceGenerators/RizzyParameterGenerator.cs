#nullable enable

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO; // Added for StringReader
using System.Linq;
using System.Text;
using System.Threading; // Added for CancellationToken
using System.Xml;

#if !NET5_0_OR_GREATER
// ReSharper disable once CheckNamespace
namespace System.Runtime.CompilerServices
{
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static class IsExternalInit { }
}
#endif

namespace Rizzy.SourceGenerators
{
    [Generator(LanguageNames.CSharp)]
    public class RizzyParameterGenerator : IIncrementalGenerator
    {
        private const string RizzyParameterizeAttributeFullName = "Rizzy.RizzyParameterizeAttribute";
        private const string ParameterAttributeFullName = "Microsoft.AspNetCore.Components.ParameterAttribute";
        private const string EditorRequiredAttributeFullName = "Microsoft.AspNetCore.Components.EditorRequiredAttribute";
        private const string ComponentBaseFullName = "Microsoft.AspNetCore.Components.ComponentBase";

        private const string RizzyParameterizeAttributeSource = @"// <auto-generated/>
#nullable enable
namespace Rizzy
{
    /// <summary>Marks a Blazor component for which a <c>Params</c> helper should be generated.</summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class RizzyParameterizeAttribute : global::System.Attribute   // ← was public
    {
        public RizzyParameterizeAttribute() { }
    }
}
#nullable restore
";

/// <summary>
/// Called by the compiler to initialize the generator and register generation steps.
/// </summary>
/// <param name="context">The incremental generator initialization context.</param>
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    // Debugger.Launch(); // Uncomment to debug during build

    // ALWAYS add the attribute source via PostInitializationOutput.
    // This is the most reliable way to ensure it's available for the compilation
    // when the main ExecuteGeneration step runs.
    // This will lead to CS0436 if Rizzy.dll (also using this generator) is referenced,
    // which is an acceptable trade-off for ensuring the generator works standalone.
    context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
        "RizzyParameterizeAttribute.g.cs",
        SourceText.From(RizzyParameterizeAttributeSource, Encoding.UTF8)));

    // Pipeline to find relevant ClassDeclarationSyntax nodes
    IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
        .CreateSyntaxProvider(
            predicate: static (s, token) => IsSyntaxTargetForGeneration(s, token),
            transform: static (ctx, token) => GetSemanticTargetForGeneration(ctx, token))
        .Where(static m => m is not null)!;

    // Combine with compilation
    IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
        context.CompilationProvider.Combine(classDeclarations.Collect());

    // Register the main source generation action
    context.RegisterSourceOutput(compilationAndClasses,
        (spc, source) => ExecuteGeneration(source.Item1, source.Item2, spc));
}

        /// <summary>
        /// A predicate used to quickly filter syntax nodes for potential processing.
        /// It identifies class declarations that have attributes and syntactically contain the text "RizzyParameterize".
        /// </summary>
        private static bool IsSyntaxTargetForGeneration(SyntaxNode node, CancellationToken _) =>
            node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0 &&
            // Using GetText().ToString() is more robust than node.ToString() for full content
            cds.GetText().ToString().Contains("RizzyParameterize");

        /// <summary>
        /// A transform function that converts a <see cref="GeneratorSyntaxContext"/> for a candidate syntax node
        /// into a <see cref="ClassDeclarationSyntax"/> if the node represents a class.
        /// </summary>
        private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context, CancellationToken _)
        {
            return context.Node as ClassDeclarationSyntax;
        }

        /// <summary>
        /// The main execution logic for the source generator.
        /// </summary>
        private void ExecuteGeneration(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext spc)
        {
            if (classes.IsDefaultOrEmpty) return;

            INamedTypeSymbol? parameterizeAttributeSymbol = compilation.GetTypeByMetadataName(RizzyParameterizeAttributeFullName);
            // If this is null, the attribute source wasn't added or found, or there's a namespace mismatch.
            // This is a critical check.
            if (parameterizeAttributeSymbol == null) 
            {
                // Optionally report a diagnostic to understand why it's not found
                // spc.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("RZ9999", "Debug", $"RizzyParameterizeAttribute symbol was not found by GetTypeByMetadataName. FullName used: {RizzyParameterizeAttributeFullName}", "Debug", DiagnosticSeverity.Warning, true), Location.None));
                return;
            }

            INamedTypeSymbol? parameterAttributeSymbol = compilation.GetTypeByMetadataName(ParameterAttributeFullName);
            if (parameterAttributeSymbol == null) return; 

            INamedTypeSymbol? editorRequiredAttributeSymbol = compilation.GetTypeByMetadataName(EditorRequiredAttributeFullName);
            if (editorRequiredAttributeSymbol == null) return; 

            INamedTypeSymbol? componentBaseSymbol = compilation.GetTypeByMetadataName(ComponentBaseFullName);

            var processedSymbols = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

            foreach (ClassDeclarationSyntax classDec in classes)
            {
                if (spc.CancellationToken.IsCancellationRequested) return;

                SemanticModel semanticModel = compilation.GetSemanticModel(classDec.SyntaxTree);
                if (semanticModel.GetDeclaredSymbol(classDec, spc.CancellationToken) is not INamedTypeSymbol classSymbol) continue;
                
                if (!processedSymbols.Add(classSymbol)) continue; 

                // Now, use the resolved parameterizeAttributeSymbol for the semantic check
                if (!classSymbol.GetAttributes().Any(ad => SymbolEqualityComparer.Default.Equals(ad.AttributeClass, parameterizeAttributeSymbol)))
                {
                    continue;
                }

                bool hasRizzyParameterize =
                    classSymbol.GetAttributes()
                               .Any(ad => ad.AttributeClass?.ToDisplayString() ==
                                          RizzyParameterizeAttributeFullName);
                if (!hasRizzyParameterize)
                    continue;

                // Warn (and skip) if the component is nested
                if (classSymbol.ContainingType is not null)
                {
                    spc.ReportDiagnostic(Diagnostic.Create(
                        Diagnostics.NestedTypesNotFullySupportedRule,
                        classSymbol.Locations.FirstOrDefault(),
                        classSymbol.Name));
                    continue;
                }

                // Collect all [Parameter] properties (same as before)
                var allParameters = CollectParameters(
                    classSymbol,
                    parameterAttributeSymbol,
                    editorRequiredAttributeSymbol,
                    componentBaseSymbol,
                    compilation);

                if (allParameters.Any())
                {
                    // Ensure the user‑authored .cs file is partial (same logic as before)
                    bool userDefinedCsFileIsNotPartial = classSymbol.DeclaringSyntaxReferences
                        .Select(sr => sr.GetSyntax(spc.CancellationToken))
                        .Where(syntax =>
                               !(syntax.SyntaxTree.FilePath?.EndsWith(".razor.g.cs",
                                   StringComparison.OrdinalIgnoreCase) ?? false) &&
                               (syntax.SyntaxTree.FilePath?.EndsWith(".cs",
                                   StringComparison.OrdinalIgnoreCase) ?? false))
                        .OfType<ClassDeclarationSyntax>()
                        .Any(cds => !cds.Modifiers.Any(SyntaxKind.PartialKeyword));

                    if (userDefinedCsFileIsNotPartial)
                    {
                        spc.ReportDiagnostic(Diagnostic.Create(
                            Diagnostics.ComponentMustBePartialRule,
                            classSymbol.Locations.FirstOrDefault(),
                            classSymbol.Name));
                        continue;
                    }

                    // Generate the Params helper
                    string classSource = GeneratePartialClassWithStaticMethod(classSymbol, allParameters);

                    // Create a stable, collision‑proof file name
                    string fqnForHash = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string assemblyNameForHash = classSymbol.ContainingAssembly?.Name ?? "unknownassembly";
                    string uniqueFileName =
                        $"{SanitizeFileName(classSymbol.Name)}_" +
                        $"{SanitizeFileName(classSymbol.ContainingNamespace.ToDisplayString())}_" +
                        $"{GetFnv1aHashCode(assemblyNameForHash + ':' + fqnForHash):X8}.RizzyParams.g.cs";

                    spc.AddSource(uniqueFileName, SourceText.From(classSource, Encoding.UTF8));
                }
            }
            
        }

       private List<ParameterData> CollectParameters(
            INamedTypeSymbol classSymbol,
            INamedTypeSymbol parameterAttributeSymbol,
            INamedTypeSymbol editorRequiredAttributeSymbol,
            INamedTypeSymbol? componentBaseSymbol,
            Compilation compilation)
        {
            var parametersList = new List<ParameterData>();
            var seenParameterNames = new HashSet<string>(StringComparer.Ordinal); 
            var typeHierarchy = new List<INamedTypeSymbol>();

            INamedTypeSymbol? current = classSymbol;
            while (current != null &&
                   current.SpecialType != SpecialType.System_Object &&
                   (componentBaseSymbol == null || !SymbolEqualityComparer.Default.Equals(current.OriginalDefinition, componentBaseSymbol)))
            {
                typeHierarchy.Add(current); 
                current = current.BaseType;
            }
            
            foreach (var typeInHierarchy in typeHierarchy) 
            {
                var levelParameters = typeInHierarchy.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Select(p => new 
                    {
                        Property = p,
                        Attributes = p.GetAttributes(),
                        Location = p.Locations.FirstOrDefault()?.SourceSpan.Start ?? int.MaxValue
                    })
                    .Where(pData => pData.Attributes.Any(ad => 
                        ad.AttributeClass != null &&
                        SymbolEqualityComparer.Default.Equals(ad.AttributeClass, parameterAttributeSymbol))) 
                    .Select(pData => new ParameterData( 
                        pData.Property,
                        pData.Attributes.Any(ad => ad.AttributeClass != null && SymbolEqualityComparer.Default.Equals(ad.AttributeClass, editorRequiredAttributeSymbol)), 
                        pData.Location
                    ))
                     .Where(pd => pd.PropertySymbol.DeclaredAccessibility == Accessibility.Public ||
                                 ((pd.PropertySymbol.DeclaredAccessibility == Accessibility.Protected ||
                                   pd.PropertySymbol.DeclaredAccessibility == Accessibility.Internal ||
                                   pd.PropertySymbol.DeclaredAccessibility == Accessibility.ProtectedOrInternal) &&
                                   SymbolEqualityComparer.Default.Equals(pd.PropertySymbol.ContainingAssembly, compilation.Assembly)))
                    .OrderBy(pd => pd.SourceOrder) 
                    .ToList();

                foreach (var paramData in levelParameters)
                {
                    if (seenParameterNames.Add(paramData.PropertySymbol.Name)) 
                    {
                        parametersList.Add(paramData);
                    }
                }
            }
             return parametersList
                .OrderBy(pd => (pd.IsEditorRequired || pd.PropertySymbol.Type.TypeKind == TypeKind.TypeParameter) ? 0 : 1) 
                .ThenByDescending(pd => GetInheritanceDepth(pd.PropertySymbol.ContainingType, classSymbol)) 
                .ThenBy(pd => pd.SourceOrder)
                .ToList();
        }
        
        private static int GetInheritanceDepth(ITypeSymbol? memberDeclaringType, INamedTypeSymbol topLevelComponentType)
        {
            if (memberDeclaringType == null) return int.MaxValue;
            int depth = 0;
            INamedTypeSymbol? current = topLevelComponentType; 
            while (current != null)
            {
                if (SymbolEqualityComparer.Default.Equals(current.OriginalDefinition, memberDeclaringType.OriginalDefinition))
                {
                    return depth;
                }
                depth++;
                current = current.BaseType; 
                if (current?.SpecialType == SpecialType.System_Object) break;
            }
            return int.MaxValue;
        }

        private static string SanitizeFileName(string name)
        {
            return System.Text.RegularExpressions.Regex.Replace(name, @"[<>,\s\.:`]", "_");
        }

        private static uint GetFnv1aHashCode(string text)
        {
            const uint fnvOffsetBasis = 2166136261;
            const uint fnvPrime = 16777619;
            uint hash = fnvOffsetBasis;
            foreach (char c in text)
            {
                hash ^= c;
                hash *= fnvPrime;
            }
            return hash;
        }
        
        private string GeneratePartialClassWithStaticMethod(INamedTypeSymbol componentSymbol, List<ParameterData> parameters)
        {
            string namespaceName = componentSymbol.ContainingNamespace.IsGlobalNamespace
                ? string.Empty
                : $"namespace {componentSymbol.ContainingNamespace.ToDisplayString()}";

            string className = componentSymbol.Name;
            string typeParametersDeclaration = componentSymbol.IsGenericType
                ? "<" + string.Join(", ", componentSymbol.TypeParameters.Select(tp => tp.Name)) + ">"
                : "";
            string crefTypeName = componentSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

            var methodBuilder = new StringBuilder();

            methodBuilder.AppendLine($@"    /// <summary>");
            methodBuilder.AppendLine($@"    /// Creates a dictionary of parameters for the <see cref=""{XmlEncode(crefTypeName)}""/> component, including inherited parameters.");
            methodBuilder.AppendLine($@"    /// Parameters marked with <see cref=""{EditorRequiredAttributeFullName}""/> or those that are generic type parameters (e.g., TValue) are required arguments in this helper method.");
            methodBuilder.AppendLine($@"    /// Other optional concrete type parameters can be omitted by passing <see langword=""null""/> (if the type allows it) or by not providing the argument if it has a default value of <see langword=""null""/>.");
            methodBuilder.AppendLine($@"    /// Optional concrete type parameters provided as <see langword=""null""/> are not added to the resulting dictionary.");
            methodBuilder.AppendLine($@"    /// Generated by Rizzy.SourceGenerators.");
            methodBuilder.AppendLine($@"    /// </summary>");

            foreach (var paramData in parameters) 
            {
                string paramNameCamelCase = ToCamelCase(paramData.PropertySymbol.Name);
                string? rawSummary = GetXmlDocsSummary(paramData.PropertySymbol);
                string paramSummaryFallback = $"The value for the <c>{paramData.PropertySymbol.Name}</c> parameter.";
                string finalSummary = rawSummary ?? paramSummaryFallback;

                var summaryLines = finalSummary.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
                
                methodBuilder.Append($@"    /// <param name=""{paramNameCamelCase}"">");
                for (int i = 0; i < summaryLines.Length; i++)
                {
                    if (i > 0) 
                    {
                        methodBuilder.AppendLine(); 
                        methodBuilder.Append($"    /// {XmlEncode(summaryLines[i])}"); 
                    }
                    else 
                    {
                        methodBuilder.Append(XmlEncode(summaryLines[i]));
                    }
                }
                methodBuilder.AppendLine("</param>");
            }
            methodBuilder.AppendLine($@"    /// <returns>A <see cref=""global::System.Collections.Generic.Dictionary{{string,object}}"" /> containing the component parameters.</returns>");
            
            methodBuilder.Append($"    public static global::System.Collections.Generic.Dictionary<string, object?> Params(");

            var firstParam = true;
            foreach (var paramData in parameters)
            {
                if (!firstParam) methodBuilder.Append(", ");

                IPropertySymbol property = paramData.PropertySymbol;
                string paramTypeString = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                string paramName = ToCamelCase(property.Name);
                bool isGenericTypeParameter = property.Type.TypeKind == TypeKind.TypeParameter;

                if (paramData.IsEditorRequired || isGenericTypeParameter)
                {
                    methodBuilder.Append($"{paramTypeString} {paramName}");
                }
                else 
                {
                    if (property.Type.IsReferenceType || property.Type.NullableAnnotation == NullableAnnotation.Annotated)
                    {
                        string typeWithQuestion = paramTypeString.EndsWith("?") ? paramTypeString : $"{paramTypeString}?";
                        methodBuilder.Append($"{typeWithQuestion} {paramName} = null");
                    }
                    else if (property.Type.IsValueType) 
                    {
                        methodBuilder.Append($"global::System.Nullable<{paramTypeString}> {paramName} = null");
                    }
                }
                firstParam = false;
            }
            methodBuilder.AppendLine(")");
            methodBuilder.AppendLine("    {");
            methodBuilder.AppendLine("        var parameters = new global::System.Collections.Generic.Dictionary<string, object?>(global::System.StringComparer.Ordinal);");

            foreach (var paramData in parameters)
            {
                string dictKey = paramData.PropertySymbol.Name;
                string valueName = ToCamelCase(paramData.PropertySymbol.Name);
                bool isGenericTypeParameter = paramData.PropertySymbol.Type.TypeKind == TypeKind.TypeParameter;

                if (paramData.IsEditorRequired || isGenericTypeParameter)
                {
                    methodBuilder.AppendLine($"        parameters.Add(\"{dictKey}\", {valueName});");
                }
                else 
                {
                    methodBuilder.AppendLine($"        if ({valueName} != null)");
                    methodBuilder.AppendLine( "        {");
                    methodBuilder.AppendLine($"            parameters.Add(\"{dictKey}\", {valueName});");
                    methodBuilder.AppendLine( "        }");
                }
            }

            methodBuilder.AppendLine("        return parameters;");
            methodBuilder.AppendLine("    }");

            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated/>");
            sourceBuilder.AppendLine("#nullable enable"); 
            sourceBuilder.AppendLine("using global::System;"); 
            sourceBuilder.AppendLine("using global::System.Collections.Generic;"); 
            sourceBuilder.AppendLine("using global::Microsoft.AspNetCore.Components;");
            sourceBuilder.AppendLine();

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sourceBuilder.AppendLine(namespaceName);
                sourceBuilder.AppendLine("{");
            }

            string accessibility = componentSymbol.DeclaredAccessibility switch {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                _ => "public"
            };

            sourceBuilder.AppendLine($@"    /// <summary>");
            sourceBuilder.AppendLine($@"    /// Provides a generated helper method <c>Params()</c> for creating a parameter dictionary for the <see cref=""{XmlEncode(crefTypeName)}""/> component.");
            sourceBuilder.AppendLine($@"    /// This <see langword=""partial""/> class is generated by Rizzy.SourceGenerators.");
            sourceBuilder.AppendLine($@"    /// </summary>");

            sourceBuilder.Append($"    {accessibility} partial class {className}{typeParametersDeclaration}");
            if (componentSymbol.IsGenericType)
            {
                sourceBuilder.Append(GetGenericConstraints(componentSymbol));
            }
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("    {");
            sourceBuilder.Append(methodBuilder.ToString());
            sourceBuilder.AppendLine("    }");

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sourceBuilder.AppendLine("}");
            }

            return sourceBuilder.ToString();
        }
        
        private string XmlEncode(string? text)
        {
            if (string.IsNullOrEmpty(text)) return string.Empty;
            return System.Security.SecurityElement.Escape(text) ?? text!;
        }

        private string? GetXmlDocsSummary(ISymbol symbol)
        {
            string? xmlDocs = symbol.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: System.Threading.CancellationToken.None);
            if (string.IsNullOrWhiteSpace(xmlDocs)) return null;
            if (!xmlDocs!.TrimStart().StartsWith("<member", StringComparison.OrdinalIgnoreCase) || !xmlDocs.Contains("<summary")) return null;

            try
            {
                using (var stringReader = new StringReader(xmlDocs)) 
                using (var xmlReader = XmlReader.Create(stringReader, new XmlReaderSettings { ConformanceLevel = ConformanceLevel.Fragment }))
                {
                    while (xmlReader.Read())
                    {
                        if (xmlReader.NodeType == XmlNodeType.Element && xmlReader.Name.Equals("summary", StringComparison.OrdinalIgnoreCase))
                        {
                            string summaryContent = xmlReader.ReadInnerXml();
                            return string.IsNullOrWhiteSpace(summaryContent) ? null : summaryContent.Trim();
                        }
                    }
                }
            }
            catch (XmlException) { return null; }
            catch (Exception) { return null; } 
            return null;
        }

        private string GetGenericConstraints(INamedTypeSymbol classSymbol)
        {
            var constraintsBuilder = new StringBuilder();
            foreach (var tp in classSymbol.TypeParameters)
            {
                var constraints = new List<string>();
                if (tp.HasReferenceTypeConstraint) constraints.Add("class");
                if (tp.HasValueTypeConstraint) constraints.Add("struct");
                if (tp.ConstraintTypes.Any())
                {
                     constraints.AddRange(tp.ConstraintTypes
                       .Where(ct => ct.SpecialType != SpecialType.System_Object)
                       .Select(ct => ct.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
                }
                if (tp.HasConstructorConstraint) constraints.Add("new()");

                if (constraints.Count > 0)
                {
                    constraintsBuilder.Append($" where {tp.Name} : {string.Join(", ", constraints)}");
                }
            }
            return constraintsBuilder.ToString();
        }

        private string ToCamelCase(string name)
        {
            if (string.IsNullOrEmpty(name) || char.IsLower(name[0]))
                return name;
            return char.ToLowerInvariant(name[0]) + name.Substring(1);
        }

        private record ParameterData(IPropertySymbol PropertySymbol, bool IsEditorRequired, int SourceOrder);

        private static class Diagnostics
        {
            public static readonly DiagnosticDescriptor ComponentMustBePartialRule = new (
                id: "RZ0001",
                title: "Component must be partial for RizzyParams generation",
                messageFormat: "Component '{0}' implemented in a .cs file must be declared 'partial' to generate the Rizzy 'Params' helper method. .razor files are implicitly partial.",
                category: "Rizzy.SourceGenerator",
                DiagnosticSeverity.Error,
                isEnabledByDefault: true);

            public static readonly DiagnosticDescriptor NestedTypesNotFullySupportedRule = new (
                id: "RZ0002",
                title: "Nested component types not fully supported for Params generation",
                messageFormat: "Component '{0}' is a nested type. Rizzy 'Params' helper generation for nested types is currently not supported. Consider making it a top-level type.",
                category: "Rizzy.SourceGenerator",
                DiagnosticSeverity.Warning,
                isEnabledByDefault: true);
        }
    }
}